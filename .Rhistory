}
error_one(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, k, seed = NULL)
alf_integ2 <- function(k, x1, x2, n1, n2, alpha0, alpha1, alpha2, j, N1, N2, n_bootstrap, seed = NULL) {
i <- seq(1, N1)
MC1 <- tryCatch({
mean(sapply(i, error_one, x1 = x1, x2 = x2, n1 = n1, n2 = n2, alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
i = i, N2 = N2, n_bootstrap = n_bootstrap, k = k, seed = seed), na.rm = TRUE)
}, error = function(e) {
stop("Error en el cálculo de Monte Carlo: ", e$message)
})
return(MC1)
}
alf_integ2(k, x1, x2, n1, n2, alpha0, alpha1, alpha2, j, N1, N2, n_bootstrap, seed = NULL)
#' Compute Monte Carlo Approximation for Evidence
#'
#' This function computes a Monte Carlo approximation for evidence by repeatedly calling `error_one`
#' over a sequence of iterations. If any errors occur during the computation, it stops with a descriptive error message.
#'
#' @param k Numeric. The parameter value for which the approximation is computed.
#' @param x1 Numeric vector. Observations for the first sample.
#' @param x2 Numeric vector. Observations for the second sample.
#' @param n1 Integer. Number of trials for the first sample.
#' @param n2 Integer. Number of trials for the second sample.
#' @param alpha0 Numeric. First shape parameter.
#' @param alpha1 Numeric. Second shape parameter.
#' @param alpha2 Numeric. Third shape parameter.
#' @param j Integer. Index for the iteration loop.
#' @param N1 Integer. Number of iterations for the first loop.
#' @param N2 Integer. Number of iterations for the second loop.
#' @param n_bootstrap Integer. Number of bootstrap samples.
#' @param seed Integer. Seed for random number generation. Default is `NULL`, which generates a random seed.
#'
#' @return Numeric. The Monte Carlo approximation, or stops with an error message if something goes wrong.
#'
#' @examples
#' alf_integ2(k = 0.5, x1 = c(1, 2), x2 = c(2, 3), n1 = 10, n2 = 12, alpha0 = 1, alpha1 = 2, alpha2 = 3, j = 1, N1 = 100, N2 = 100, n_bootstrap = 1000)
#'
#' @importFrom hypergeo genhypergeo
#' @export
alf_integ2 <- function(k, x1, x2, n1, n2, alpha0, alpha1, alpha2, j, N1, N2, n_bootstrap, seed = NULL) {
i <- seq(1, N1)
MC1 <- tryCatch({
mean(sapply(i, error_one, x1 = x1, x2 = x2, n1 = n1, n2 = n2, alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
i = i, j = j, N2 = N2, n_bootstrap = n_bootstrap, k = k, seed = seed), na.rm = TRUE)
}, error = function(e) {
stop("Error en el cálculo de Monte Carlo: ", e$message)
})
return(MC1)
}
i <- seq(1, N1)
MC1 <- tryCatch({
mean(sapply(i, error_one, x1 = x1, x2 = x2, n1 = n1, n2 = n2, alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
i = i, j = j, N2 = N2, n_bootstrap = n_bootstrap, k = k, seed = seed), na.rm = TRUE)
}, error = function(e) {
stop("Error en el cálculo de Monte Carlo: ", e$message)
})
N1
N1 <- 1
N2
N1
N2
N2 <- 1
i <- seq(1, N1)
MC1 <- tryCatch({
mean(sapply(i, error_one, x1 = x1, x2 = x2, n1 = n1, n2 = n2, alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
i = i, j = j, N2 = N2, n_bootstrap = n_bootstrap, k = k, seed = seed), na.rm = TRUE)
}, error = function(e) {
stop("Error en el cálculo de Monte Carlo: ", e$message)
})
ev10 <- evidence(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, seed)
Ind <- I(ev10 <= k)
#if (is.na(Ind)) {
#  stop("Error: 'Ind' es NA, verifique los parámetros de entrada o el cálculo de 'ev10'.")
#}
#if (is.na(f_ver)) {
#  stop("Error: 'f_ver' es NA, verifique los parámetros de entrada o el cálculo de 'f_ver'.")
#}
error1 <- f_ver * Ind
error1
i <- seq(1, N1)
MC1 <- tryCatch({
mean(sapply(i, error_one, x1 = x1, x2 = x2, n1 = n1, n2 = n2, alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
i = i, j = j, N2 = N2, n_bootstrap = n_bootstrap, k = k, seed = seed), na.rm = TRUE)
}, error = function(e) {
stop("Error en el cálculo de Monte Carlo: ", e$message)
})
#' Compute Monte Carlo Approximation for Evidence
#'
#' This function computes a Monte Carlo approximation for evidence by repeatedly calling `error_one`
#' over a sequence of iterations. If any errors occur during the computation, it stops with a descriptive error message.
#'
#' @param k Numeric. The parameter value for which the approximation is computed.
#' @param x1 Numeric vector. Observations for the first sample.
#' @param x2 Numeric vector. Observations for the second sample.
#' @param n1 Integer. Number of trials for the first sample.
#' @param n2 Integer. Number of trials for the second sample.
#' @param alpha0 Numeric. First shape parameter.
#' @param alpha1 Numeric. Second shape parameter.
#' @param alpha2 Numeric. Third shape parameter.
#' @param j Integer. Index for the iteration loop.
#' @param N1 Integer. Number of iterations for the first loop.
#' @param N2 Integer. Number of iterations for the second loop.
#' @param n_bootstrap Integer. Number of bootstrap samples.
#' @param seed Integer. Seed for random number generation. Default is `NULL`, which generates a random seed.
#'
#' @return Numeric. The Monte Carlo approximation, or stops with an error message if something goes wrong.
#'
#' @examples
#' alf_integ2(k = 0.5, x1 = c(1, 2), x2 = c(2, 3), n1 = 10, n2 = 12, alpha0 = 1, alpha1 = 2, alpha2 = 3, j = 1, N1 = 100, N2 = 100, n_bootstrap = 1000)
#'
#' @importFrom hypergeo genhypergeo
#' @export
alf_integ2 <- function(k, x1, x2, n1, n2, alpha0, alpha1, alpha2, j, N1, N2, n_bootstrap, seed = NULL) {
i_seq <- seq(1, N1)
MC1 <- tryCatch({
mean(sapply(i_seq, function(i) error_one(x1 = x1, x2 = x2, n1 = n1, n2 = n2, alpha0 = alpha0, alpha1 = alpha1,
alpha2 = alpha2, i = i, j = j, N2 = N2, n_bootstrap = n_bootstrap, k = k, seed = seed)), na.rm = TRUE)
}, error = function(e) {
stop("Error en el cálculo de Monte Carlo: ", e$message)
})
return(MC1)
}
alf_integ2(k, x1, x2, n1, n2, alpha0, alpha1, alpha2, j, N1, N2, n_bootstrap, seed = NULL)
#' Calculate Evidence for the Beta-Binomial Model
#'
#' This function calculates the evidence for a beta-binomial model using variational inference under type II error
#' via Stan and genetic algorithms to optimize parameters. It returns the calculated evidence (`ev10`).
#'
#' @param x1 Numeric vector. Observations for the first sample.
#' @param x2 Numeric vector. Observations for the second sample.
#' @param n1 Integer. Number of trials for the first sample.
#' @param n2 Integer. Number of trials for the second sample.
#' @param alpha0 Numeric. First shape parameter.
#' @param alpha1 Numeric. Second shape parameter.
#' @param alpha2 Numeric. Third shape parameter.
#' @param i Integer. Index for the observation in both samples.
#' @param j Integer. Index for Theta sampling.
#' @param N2 Integer. Number of samples for `Theta1`.
#' @param n_bootstrap Integer. Number of bootstrap samples for variational Bayes.
#' @param seed Integer. Seed for random number generation. Default is `NULL`, which generates a random seed.
#'
#' @return Numeric. The calculated evidence `ev10`.
#'
#' @examples
#' evidence(x1 = c(1, 0), x2 = c(1, 1), n1 = 2, n2 = 2, alpha0 = 0.6, alpha1 = 0.65, alpha2 = 0.7, i = 1, j = 1, N2 = 100, n_bootstrap = 1000)
#'
#' @export
evidence_beta <- function(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, theta1, theta2, seed = NULL) {
if (is.null(seed)) {
seed <- sample.int(.Machine$integer.max, 1)
}
f2 <- function(X1,X2,theta1,theta2) {
exp(dbinom(X1,n1,theta1[j],log=T)+dbinom(X2,n2,theta2[j],log=T))
}
alpha <- sum(c(alpha0, alpha1, alpha2))
Theta1 <- rbeta(N2, 1, 1)
f_ver <- f2(x1[i], x2[i], theta1[j], theta2[j])
u <- c(alpha, x1[i] + alpha1, x2[i] + alpha2)
l <- c(n1 + alpha, n2 + alpha)
stan_model <- rstan::stan_model(file = 'BBpost3.stan', verbose = TRUE)
GA_ev <- ga(type = "real-valued",
fitness = function(x) {
densBB_functor(x1, x2, n1, n2, u, l, alpha0, alpha1, alpha2, i, TRUE)(x[1])
},
lower = c(0), upper = c(0.99),
popSize = 50, maxiter = 1000, run = 100,
monitor = FALSE)
supremo_ga_ev <- GA_ev@solution[1, ] |> as.numeric()
n <- as.integer(c(n1, n2))
X <- c(x1[i], x2[i])
P <- length(X)
stan_data <- list(P = P, X = X, n = n, alpha1 = alpha0, alpha2 = alpha1, alpha3 = alpha2)
sink(nullfile())
stan_vb <- rstan::vb(object = stan_model, data = stan_data, seed = seed,
output_samples = n_bootstrap)
sink()
Thetas <- cbind(
extract(stan_vb)$Theta[, 1] |> as.vector(),
extract(stan_vb)$Theta[, 2] |> as.vector()
)
densBB <- densBB_functor(x1, x2, n1, n2, u, l, alpha0, alpha1, alpha2, i, equal_thetas = FALSE)
ev10 <- mean(apply(Thetas, 1,
function(t) { I(densBB(t[1], t[2]) < densBB_functor(x1, x2, n1, n2, u, l, alpha0, alpha1, alpha2, i, equal_thetas = TRUE)(supremo_ga_ev))
}), na.rm = TRUE)
return(ev10)
}
evidence_beta(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, theta1, theta2, seed = NULL)
error_two(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, k, seed = NULL)
#' Calculate Error Based on Evidence
#'
#' This function calculates an error metric (`error2`) based on the evidence calculated by the `evidence` function under type II error.
#' It includes checks for `NA` values in the calculated evidence (`ev10`) and verification value (`f_ver`),
#' and throws an error if any of them are `NA`.
#'
#' @param x1 Numeric vector. Observations for the first sample.
#' @param x2 Numeric vector. Observations for the second sample.
#' @param n1 Integer. Number of trials for the first sample.
#' @param n2 Integer. Number of trials for the second sample.
#' @param alpha0 Numeric. First shape parameter.
#' @param alpha1 Numeric. Second shape parameter.
#' @param alpha2 Numeric. Third shape parameter.
#' @param i Integer. Index for the observation in both samples.
#' @param j Integer. Index for Theta generation.
#' @param N2 Integer. Number of samples for `Theta1`.
#' @param n_bootstrap Integer. Number of bootstrap samples for variational Bayes.
#' @param k Numeric. Threshold for calculating the indicator `Ind`.
#' @param seed Integer. Seed for random number generation. Default is `NULL`, which generates a random seed.
#'
#' @return Numeric. The calculated error `error2`.
#'
#' @examples
#' error_one(x1 = c(1, 2), x2 = c(2, 3), n1 = 10, n2 = 12, alpha0 = 1, alpha1 = 2, alpha2 = 3, i = 1, j = 1, N2 = 100, n_bootstrap = 1000, k = 0.5)
#'
#' @importFrom hypergeo genhypergeo
#' @importFrom MCMCpack MCMCmetrop1R
#' @export
error_two <- function(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, k, seed = NULL) {
##No estoy muy seguro de como cambiar esta parte
priorB2<- function(theta) {
if( any(theta > 1) | any(theta < 0) ) {
return(-Inf)
}
a<-alpha0+alpha1+alpha2
log_f<-lgamma(a)-
lgamma(alpha0)-lgamma(alpha1)-
lgamma(alpha2)+
(alpha1-1)*log(theta[1])+(alpha2+alpha1-1)*log(1-theta[1])+
(alpha2-1)*log(theta[2])+(alpha1+alpha1-1)*log(1-theta[2])-
(a)*log(1-theta[1]*theta[2])
return(log_f)
}
theta.samp <- MCMCmetrop1R(priorB2, theta.init=c(0.3,0.3),
thin=10, mcmc=200000, burnin=5000,
# tune=c(1, 1),
verbose=500, logfun=TRUE,
force.samp=T,
optim.lower=c(0.01, 0.01),
optim.upper = c(0.99, 0.99),
optim.method = "L-BFGS-B")
Theta11<-theta.samp[, 1][seq(20,20000,40)]
Theta22<-theta.samp[, 2][seq(20,20000,40)]
N2=length(Theta11)
N1=length(Theta22)
ev10 <- evidence_beta(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, theta1 = Theta11, theta2 = Theta22 ,seed)
Ind <- I(ev10 > k)
error2 <- f_ver * Ind
return(error2)
}
error_two(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, k, seed = NULL)
#' Compute Monte Carlo Approximation for Evidence
#'
#' This function computes a Monte Carlo approximation for evidence by repeatedly calling `error_two`
#' over a sequence of iterations. If any errors occur during the computation, it stops with a descriptive error message.
#'
#' @param k Numeric. The parameter value for which the approximation is computed.
#' @param x1 Numeric vector. Observations for the first sample.
#' @param x2 Numeric vector. Observations for the second sample.
#' @param n1 Integer. Number of trials for the first sample.
#' @param n2 Integer. Number of trials for the second sample.
#' @param alpha0 Numeric. First shape parameter.
#' @param alpha1 Numeric. Second shape parameter.
#' @param alpha2 Numeric. Third shape parameter.
#' @param j Integer. Index for the iteration loop.
#' @param N1 Integer. Number of iterations for the first loop.
#' @param N2 Integer. Number of iterations for the second loop.
#' @param n_bootstrap Integer. Number of bootstrap samples.
#' @param seed Integer. Seed for random number generation. Default is `NULL`, which generates a random seed.
#'
#' @return Numeric. The Monte Carlo approximation, or stops with an error message if something goes wrong.
#'
#' @examples
#' alf_integ2(k = 0.5, x1 = c(1, 2), x2 = c(2, 3), n1 = 10, n2 = 12, alpha0 = 1, alpha1 = 2, alpha2 = 3, j = 1, N1 = 100, N2 = 100, n_bootstrap = 1000)
#'
#' @export
alf_integ2_beta <- function(k, x1, x2, n1, n2, alpha0, alpha1, alpha2, j, N1, N2, n_bootstrap, seed = NULL) {
i <- seq(1, N1)
MC1 <- tryCatch({
mean(sapply(i, error_two, x1 = x1, x2 = x2, n1 = n1, n2 = n2, alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
i = i, N2 = N2, n_bootstrap = n_bootstrap, k = k, seed = seed), na.rm = TRUE)
}, error = function(e) {
stop("Error en el cálculo de Monte Carlo: ", e$message)
})
return(MC1)
}
alf_integ2_beta(k, x1, x2, n1, n2, alpha0, alpha1, alpha2, j, N1, N2, n_bootstrap, seed = NULL)
error2
MC1
MC1
k
k
n2
n1
N1
N2
alpha0
alpha1
alpha2
i
N2
n_bootstrap
h
j
k
seed
seed <- 456
seed
set.seed(456)
k <- c(0.0000, 0.0101, 0.0202, 0.0303, 0.0404, 0.0505, 0.0606,
0.0707, 0.0808, 0.0909, 0.1010, 0.1111, 0.1212, 0.1313,
0.1414, 0.1515, 0.1616, 0.1717, 0.1818, 0.1919, 0.2020,
0.2121, 0.2222, 0.2323, 0.2424, 0.2525, 0.2626, 0.2727,
0.2828, 0.2929, 0.3030, 0.3131, 0.3232, 0.3333, 0.3434,
0.3535, 0.3636, 0.3737, 0.3838, 0.3939, 0.4040, 0.4141,
0.4242, 0.4343, 0.4444, 0.4545, 0.4646, 0.4747, 0.4848,
0.4949, 0.5051, 0.5152, 0.5253, 0.5354, 0.5455, 0.5556,
0.5657, 0.5758, 0.5859, 0.5960, 0.6061, 0.6162, 0.6263,
0.6364, 0.6465, 0.6566, 0.6667, 0.6768, 0.6869, 0.6970,
0.7071, 0.7172, 0.7273, 0.7374, 0.7475, 0.7576, 0.7677,
0.7778, 0.7879, 0.7980, 0.8081, 0.8182, 0.8283, 0.8384,
0.8485, 0.8586, 0.8687, 0.8788, 0.8889, 0.8990, 0.9091,
0.9192, 0.9293, 0.9394, 0.9495, 0.9596, 0.9697, 0.9798,
0.9899, 1.0000)
alf_integ2_beta(k, x1, x2, n1, n2, alpha0, alpha1, alpha2, j, N1, N2, n_bootstrap, seed = NULL)
f_ver
f_ver
f2 <- function(X1,X2,theta1,theta2) {
exp(dbinom(X1,n1,theta1[j],log=T)+dbinom(X2,n2,theta2[j],log=T))
}
alpha <- sum(c(alpha0, alpha1, alpha2))
Theta1 <- rbeta(N2, 1, 1)
f_ver <- f2(x1[i], x2[i], theta1[j], theta2[j])
f_ver
ev10
seed
u
l
alpha
supremo_ga_ev
n
X
P
Thetas
n_bootstrap
if (is.null(seed)) {
seed <- sample.int(.Machine$integer.max, 1)
}
seed <- 456
f2 <- function(X1,X2,theta1,theta2) {
exp(dbinom(X1,n1,theta1[j],log=T)+dbinom(X2,n2,theta2[j],log=T))
}
alpha <- sum(c(alpha0, alpha1, alpha2))
Theta1 <- rbeta(N2, 1, 1)
f_ver <- f2(x1[i], x2[i], theta1[j], theta2[j])
u <- c(alpha, x1[i] + alpha1, x2[i] + alpha2)
l <- c(n1 + alpha, n2 + alpha)
stan_model <- rstan::stan_model(file = 'BBpost3.stan', verbose = TRUE)
GA_ev <- ga(type = "real-valued",
fitness = function(x) {
densBB_functor(x1, x2, n1, n2, u, l, alpha0, alpha1, alpha2, i, TRUE)(x[1])
},
lower = c(0), upper = c(0.99),
popSize = 50, maxiter = 1000, run = 100,
monitor = FALSE)
supremo_ga_ev <- GA_ev@solution[1, ] |> as.numeric()
n <- as.integer(c(n1, n2))
X <- c(x1[i], x2[i])
P <- length(X)
stan_data <- list(P = P, X = X, n = n, alpha1 = alpha0, alpha2 = alpha1, alpha3 = alpha2)
sink(nullfile())
stan_vb <- rstan::vb(object = stan_model, data = stan_data, seed = seed,
output_samples = n_bootstrap)
sink()
Thetas <- cbind(
extract(stan_vb)$Theta[, 1] |> as.vector(),
extract(stan_vb)$Theta[, 2] |> as.vector()
)
Thetas
error_two(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, k, seed = 456)
error_two(x1, x2, n1, n2, alpha0, alpha1, alpha2, i, j, N2, n_bootstrap, k, seed = 456)
i <- seq(1, N1)
MC1 <- tryCatch({
mean(sapply(i, error_two, x1 = x1, x2 = x2, n1 = n1, n2 = n2, alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
i = i, N2 = N2, n_bootstrap = n_bootstrap, k = k, seed = seed), na.rm = TRUE)
}, error = function(e) {
stop("Error en el cálculo de Monte Carlo: ", e$message)
})
MC1
alf_integ2_beta(k, x1, x2, n1, n2, alpha0, alpha1, alpha2, j, N1, N2, n_bootstrap, seed = 456)
k
library(furrr)
library(future)
m_grids_k <- list(
round(seq(0.0000, 0.0909, length.out = 10), 4),
round(seq(0.1010, 0.1919, length.out = 10), 4),
round(seq(0.2020, 0.2929, length.out = 10), 4),
round(seq(0.3030, 0.3939, length.out = 10), 4),
round(seq(0.4040, 0.4949, length.out = 10), 4),
round(seq(0.5051, 0.5960, length.out = 10), 4),
round(seq(0.6061, 0.6970, length.out = 10), 4),
round(seq(0.7071, 0.7980, length.out = 10), 4),
round(seq(0.8081, 0.8990, length.out = 10), 4),
round(seq(0.9091, 1.0000, length.out = 10), 4)
)
j <- seq(1, N2)
cores <- 10
plan(multisession, workers = cores)
calculate_for_grid <- function(m_grid_k) {
future_map_dbl(
m_grid_k,
~mean(sapply(j, alf_integ2_beta, k = .x, x1 = x1, x2 = x2, n1 = n1, n2 = n2,
alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2, j = j,
N1 = N1, N2 = N2, n_bootstrap = n_bootstrap, seed = seed),
na.rm = TRUE),
.options = furrr_options(seed = TRUE)
)
}
beta_results_all_grids <- lapply(m_grids_k, calculate_for_grid)
library(furrr)
library(future)
m_grids_k <- list(
round(seq(0.0000, 0.0909, length.out = 10), 4),
round(seq(0.1010, 0.1919, length.out = 10), 4),
round(seq(0.2020, 0.2929, length.out = 10), 4),
round(seq(0.3030, 0.3939, length.out = 10), 4),
round(seq(0.4040, 0.4949, length.out = 10), 4),
round(seq(0.5051, 0.5960, length.out = 10), 4),
round(seq(0.6061, 0.6970, length.out = 10), 4),
round(seq(0.7071, 0.7980, length.out = 10), 4),
round(seq(0.8081, 0.8990, length.out = 10), 4),
round(seq(0.9091, 1.0000, length.out = 10), 4)
)
j <- seq(1, N2)
cores <- 10
plan(multisession, workers = cores)
calculate_for_grid <- function(m_grid_k) {
future_map_dbl(
m_grid_k,
~mean(sapply(j, function(current_j) {
alf_integ2_beta(k = .x, x1 = x1, x2 = x2, n1 = n1, n2 = n2,
alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
j = current_j, N1 = N1, N2 = N2,
n_bootstrap = n_bootstrap, seed = seed)
}, na.rm = TRUE)),
.options = furrr_options(seed = TRUE)
)
}
# Aplicar la función calculate_for_grid en cada grid de k
beta_results_all_grids <- future_map(m_grids_k, calculate_for_grid, .options = furrr_options(seed = TRUE))
m_grids_k <- list(
round(seq(0.0000, 0.0909, length.out = 10), 4),
round(seq(0.1010, 0.1919, length.out = 10), 4),
round(seq(0.2020, 0.2929, length.out = 10), 4),
round(seq(0.3030, 0.3939, length.out = 10), 4),
round(seq(0.4040, 0.4949, length.out = 10), 4),
round(seq(0.5051, 0.5960, length.out = 10), 4),
round(seq(0.6061, 0.6970, length.out = 10), 4),
round(seq(0.7071, 0.7980, length.out = 10), 4),
round(seq(0.8081, 0.8990, length.out = 10), 4),
round(seq(0.9091, 1.0000, length.out = 10), 4)
)
j <- seq(1, N2)
cores <- 10
plan(multisession, workers = cores)
calculate_for_grid <- function(m_grid_k) {
future_map_dbl(
m_grid_k,
~mean(sapply(j, function(current_j) {
alf_integ2_beta(k = .x, x1 = x1, x2 = x2, n1 = n1, n2 = n2,
alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
j = current_j, N1 = N1, N2 = N2,
n_bootstrap = n_bootstrap, seed = seed)
}, na.rm = TRUE)),
.options = furrr_options(seed = TRUE)
)
}
# Aplicar la función calculate_for_grid en cada grid de k
beta_results_all_grids <- lapply(m_grids_k, calculate_for_grid)
m_grids_k <- list(
round(seq(0.0000, 0.0909, length.out = 10), 4),
round(seq(0.1010, 0.1919, length.out = 10), 4),
round(seq(0.2020, 0.2929, length.out = 10), 4),
round(seq(0.3030, 0.3939, length.out = 10), 4),
round(seq(0.4040, 0.4949, length.out = 10), 4),
round(seq(0.5051, 0.5960, length.out = 10), 4),
round(seq(0.6061, 0.6970, length.out = 10), 4),
round(seq(0.7071, 0.7980, length.out = 10), 4),
round(seq(0.8081, 0.8990, length.out = 10), 4),
round(seq(0.9091, 1.0000, length.out = 10), 4)
)
j <- seq(1, N2)
cores <- 10
plan(multisession, workers = cores)
calculate_for_grid <- function(m_grid_k) {
future_map_dbl(
m_grid_k,
~{
# Aplicar sapply sobre 'j' y calcular el promedio sin NA
results <- sapply(j, function(current_j) {
alf_integ2_beta(k = .x, x1 = x1, x2 = x2, n1 = n1, n2 = n2,
alpha0 = alpha0, alpha1 = alpha1, alpha2 = alpha2,
j = current_j, N1 = N1, N2 = N2,
n_bootstrap = n_bootstrap, seed = seed)
})
# Calcular el promedio eliminando los NA
mean(results, na.rm = TRUE)
},
.options = furrr_options(seed = TRUE)
)
}
# Aplicar la función calculate_for_grid en cada grid de k
beta_results_all_grids <- lapply(m_grids_k, calculate_for_grid)
warnings()
